/* 01-归并排序
*归并排序采用分治，即分而治之得思想，将原问题转化为一些规模较小相同得子问题，然后递归解决这些子问题，最后不断得 合并 作为在最后得结果
*/

void merge_sort(int q[], int l, int r) {
  if(l >= r) return;  // 如果左界大于或等于有界 则越界
  int mid = (l + r) >> 1;  // 中间值
  //下面着两步保证 一直二分 分到只剩下每个元素   采用二分法得递归
  merge_sort(q, l, mid);
  merge_sort(q, mid + 1, r); // 一、分完成
  
  //二、下面开始合成
  
  int k = 0, i = l, j = mid + 1;
  while (i <= mid && j <= r) {  // 保证不会越界  两边都不超过最右界
    if (q[i] < q[j]) temp[k ++] = q[i ++];  // 如果下标i对应的值 < 下标j对应的值， 则把下标i多对应的值放入临时数组，然后i继续向下遍历 
    else temp[k ++] = q[j ++];   // 如果下标j对应的值 < 下标i对应的值， 则把下标j多对应的值放入临时数组，然后j继续向下遍历 
  }
  while(i <= mid) temp[k ++] = q[i ++];  // 如果下标i对应的值还未填入临时数组, 而下标j所对应的值已全部填入临时数组，则j指向空，下标i所对应的值依次填入临时数组 
  while(j <= r) temp[k ++] = q[j ++];  // 同上
  
  for (int i = 1, j = 0; i <= r; i++, j++) q[i] = temp[j];  // 将临时数组再赋给原数组 q[]
  
}
